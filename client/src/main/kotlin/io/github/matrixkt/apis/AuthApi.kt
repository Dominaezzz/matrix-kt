package io.github.matrixkt.apis

import io.github.matrixkt.models.*
import io.ktor.client.HttpClient
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.post
import io.ktor.http.ContentType
import io.ktor.http.contentType
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.boolean
import kotlinx.serialization.json.jsonPrimitive
import kotlin.reflect.KProperty0

public class AuthApi internal constructor(private val client: HttpClient, private val accessTokenProp: KProperty0<String>) {
    private inline val accessToken: String get() = accessTokenProp.get()

    /**
     * Gets the homeserver's supported login types to authenticate users.
     * Clients should pick one of these and supply it as the type when logging in.
     *
     * **Rate-limited**: Yes.
     *
     * **Requires auth**: No.
     */
    public suspend fun getLoginFlows(): LoginFlowsResponse {
        return client.get(path = "_matrix/client/r0/login")
    }

    /**
     * Authenticates the user, and issues an access token they can use to authorize themselves in subsequent requests.
     *
     * If the client does not supply a `device_id`, the server must auto-generate one.
     *
     * The returned access token must be associated with the `device_id` supplied by the client or generated by the server.
     * The server may invalidate any access token previously associated with that device.
     * See [Relationship between access tokens and devices](https://matrix.org/docs/spec/client_server/r0.5.0#relationship-between-access-tokens-and-devices).
     *
     * **Rate-limited**: Yes.
     *
     * **Requires auth**: No.
     */
    public suspend fun login(params: LoginRequest): LoginResponse {
        return client.post(path = "_matrix/client/r0/login") {
            contentType(ContentType.Application.Json)
            body = params
        }
    }

    /**
     * Invalidates an existing access token, so that it can no longer be used for authorization.
     * The device associated with the access token is also deleted.
     * [Device keys] for the device are deleted alongside the device.
     *
     * **Rate-limited**: No.
     *
     * **Requires auth**: Yes.
     */
    public suspend fun logout() {
        return client.post(path = "_matrix/client/r0/logout") {
            header("Authorization", "Bearer $accessToken")
        }
    }

    /**
     * Invalidates all access tokens for a user, so that they can no longer be used for authorization.
     * This includes the access token that made this request.
     * All devices for the user are also deleted.
     * [Device keys](https://matrix.org/docs/spec/client_server/r0.5.0#device-keys) for the device are deleted alongside the device.
     *
     * This endpoint does not require UI authorization because UI authorization is designed to protect
     * against attacks where the someone gets hold of a single access token then takes over the account.
     * This endpoint invalidates all access tokens for the user, including the token used in the request,
     * and therefore the attacker is unable to take over the account in this way.
     *
     * **Rate-limited**: No.
     *
     * **Requires auth**: Yes.
     */
    public suspend fun logoutAll() {
        return client.post(path = "_matrix/client/r0/logout/all") {
            header("Authorization", "Bearer $accessToken")
        }
    }

    /**
     * This API endpoint uses the
     * [User-Interactive Authentication API](https://matrix.org/docs/spec/client_server/r0.5.0#user-interactive-authentication-api),
     * except in the cases where a guest account is being registered.
     *
     * Register for an account on this homeserver.
     *
     * There are two kinds of user account:
     * - user accounts. These accounts may use the full API described in this specification.
     * - guest accounts. These accounts may have limited permissions and may not be supported by all servers.
     * If registration is successful, this endpoint will issue an access token the client can use to authorize itself in subsequent requests.
     *
     * If the client does not supply a `device_id`, the server must auto-generate one.
     *
     * The server SHOULD register an account with a User ID based on the `username` provided, if any.
     * Note that the grammar of Matrix User ID localparts is restricted,
     * so the server MUST either map the provided `username` onto a `user_id` in a logical manner,
     * or reject `username`s which do not comply to the grammar, with `M_INVALID_USERNAME`.
     *
     * Matrix clients MUST NOT assume that localpart of the registered `user_id` matches the provided `username`.
     *
     * The returned access token must be associated with the `device_id` supplied by the client or generated by the server.
     * The server may invalidate any access token previously associated with that device.
     * See [Relationship between access tokens and devices](https://matrix.org/docs/spec/client_server/r0.5.0#relationship-between-access-tokens-and-devices).
     *
     * When registering a guest account,
     * all parameters in the request body with the exception of `initial_device_display_name` MUST BE ignored by the server.
     * The server MUST pick a `device_id` for the account regardless of input.
     *
     * Any user ID returned by this API must conform to the grammar given in the
     * [Matrix specification](https://matrix.org/docs/spec/appendices.html#user-identifiers).
     *
     * **Rate-limited**: Yes.
     *
     * **Requires auth**: No.
     *
     * @param[kind] The kind of account to register. Defaults to user. One of: ["guest", "user"]
     */
    public suspend fun register(kind: RegistrationKind? = null, params: RegisterRequest): RegisterResponse {
        return client.post(path = "_matrix/client/r0/register") {
            parameter("kind", kind)
            contentType(ContentType.Application.Json)
            body = params
        }
    }

    /**
     * Checks to see if a username is available, and valid, for the server.
     *
     * The server should check to ensure that, at the time of the request, the username requested is available for use.
     * This includes verifying that an application service has not claimed the username and that the username fits
     * the server's desired requirements (for example, a server could dictate that it does not permit usernames with underscores).
     *
     * Matrix clients may wish to use this API prior to attempting registration,
     * however the clients must also be aware that using this API does not normally reserve the username.
     * This can mean that the username becomes unavailable between checking its availability and attempting to register it.
     *
     * **Rate-limited**: Yes.
     *
     * **Requires auth**: No.
     */
    public suspend fun checkUsernameAvailability(username: String): Boolean {
        val response = client.get<JsonObject>(path = "_matrix/client/r0/register/available") {
            parameter("username", username)
        }
        return response["available"]!!.jsonPrimitive.boolean
    }

    /**
     * The homeserver must check that the given email address is **not** already associated with an account on this homeserver.
     * The homeserver has the choice of validating the email address itself,
     * or proxying the request to the `/validate/email/requestToken` Identity Service API.
     * The request should be proxied to the domain that is sent by the client in the `id_server`.
     * It is imperative that the homeserver keep a list of trusted Identity Servers and only proxies to those it trusts.
     *
     * **Rate-limited**: No.
     *
     * **Requires auth**: No.
     */
    public suspend fun requestTokenToRegisterEmail(params: EmailValidationRequest): TokenValidationResponse {
        return client.post(path = "_matrix/client/r0/register/email/requestToken") {
            contentType(ContentType.Application.Json)
            body = params
        }
    }

    /**
     * The homeserver must check that the given phone number is **not** already associated with an account on this homeserver.
     * The homeserver has the choice of validating the phone number itself,
     * or proxying the request to the `/validate/msisdn/requestToken` Identity Service API.
     * The request should be proxied to the domain that is sent by the client in the `id_server`.
     * It is imperative that the homeserver keep a list of trusted Identity Servers and only proxies to those it trusts.
     *
     * **Rate-limited**: No.
     *
     * **Requires auth**: No.
     */
    public suspend fun requestTokenToRegisterMSISDN(params: MSISDNValidationRequest): TokenValidationResponse {
        return client.post(path = "_matrix/client/r0/register/msisdn/requestToken") {
            contentType(ContentType.Application.Json)
            body = params
        }
    }
}
